- when **going forward** doesn't work, then think the opposite : **going backward** [174]()
- denote `dp[i][distance]` as the minimum number of choices might lead to **`TLE`** or **`MLE`**, then think the opposite: denote `dp[i][j]` as choose `j` times in `i` first elements to reach the furthest distance [871]()
- using **skyline** technique in `matrix` to maintain the minimum point state [1240]()
- graph: Floyd
- **dp 2 times** [1162]()
- **dp bitMask** [1349]()
- **overflow** might lead to a wrong calculation when returning the max (or min) value. `long` comes to rescue, and do `mod` at the end [1339]()
- exactly `K times` = **at most** `K times` - **at most** `K - 1 times`[1248]() [992]() [#](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space)

